/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/crowbar/complex.ycp
 * Package:	Configuration of crowbar
 * Summary:	Dialogs definitions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id: complex.ycp 65771 2011-09-19 07:37:30Z visnov $
 */

{

textdomain "crowbar";

import "Confirm";
import "Crowbar";
import "CWM";
import "CWMTab";
import "Label";
import "Popup";
import "Wizard";
import "IP";


include "crowbar/helps.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return Crowbar::Modified();
}

boolean ReallyAbort() {
    return !Crowbar::Modified() || Popup::ReallyAbort(true);
}

boolean PollAbort() {
    return UI::PollInput() == `abort;
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
//    if (!Confirm::MustBeRoot()) return `abort;
    boolean ret = Crowbar::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    boolean ret = Crowbar::Write();
    return ret ? `next : `abort;
}

/**
 * Overview dialog
 * @return dialog result
 *
any OverviewDialogOld() {

    // Crowbar overview dialog caption
    string caption = _("Crowbar Configuration Overview");

    list overview = [];

    map<string,map> networks    = Crowbar::networks;
    y2internal ("networks: %1", networks);

    list<term> network_names  = maplist (string name, map n, networks, {
      return `item (`id (name), name, name == "admin");
    });

    term build_ui_for_network (string name) {

      map network       = networks[name]:$[];
      return `VBox (
//        `TextEntry (`id ("conduit"), _("Conduit"), network["conduit"]:""),
        `TextEntry (`id ("subnet"), _("Subnet"), network["subnet"]:""),
        `TextEntry (`id ("netmask"), _("Netmask"), network["netmask"]:""),
        `VSpacing (0.5),
        `Left (`CheckBox (`id ("add_bridge"), _("Add Bridge"), network["add_bridge"]:false))
      );
    }

    // take current network data from UI and save it to the global map
    void store_current_network (string name) {
      foreach (string key, [ "subnet", "netmask" ], {
        string value = (string) UI::QueryWidget (`id (key), `Value);
        networks[name,key]      = value;
      });
      networks[name,"add_bridge"] = UI::QueryWidget (`id ("add_bridge"), `Value) == true;
      return;
    }

    term contents       = `HBox (`HSpacing (), `VBox (
      `VSpacing (),
      `Left (
        `ComboBox (`id (`networks), `opt (`notify), _("Networks"), network_names)
      ),
      `ReplacePoint (`id (`rp_network), build_ui_for_network (current_network)),
      `VSpacing ()
    ), `HSpacing ());

    Wizard::SetContentsButtons(caption, contents, HELPS["overview"]:"",
        Label::BackButton(), Label::FinishButton());

    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	if (ret == `abort || ret == `cancel) {
	    if (ReallyAbort()) break;
	    else continue;
	}
        else if (ret == `networks) {
            string selected     = (string) UI::QueryWidget (`id (`networks), `Value);
            if (selected != current_network)
            {
              store_current_network (current_network);
              UI::ReplaceWidget (`id (`rp_network), build_ui_for_network (selected));
              current_network   = selected;
            }
        }
        else if (ret == `next || ret == `back) {
            break;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    if (ret == `next)
    {
        store_current_network (current_network);
        Crowbar::networks        = networks;
    }
    return ret;
}
*/

    map<string,map> networks    = $[];

    string current_network      = "admin";

  /**
   * universal widget: initialize the string value of widget @param
   */
  define void InitNetwork (string id) {
    UI::ChangeWidget (`id (id), `Value, networks[current_network,id]:"");
  }

  /**
   * store the string value of given widget
   */
  define void StoreNetwork (string key, map event) {
    networks[current_network,key]      = UI::QueryWidget (`id(key), `Value);
  }

  /**
   * handler for general string-value widgets: store their value on exit/save
   */
  define symbol HandleNetwork (string key, map event) {
    y2milestone( "HandleNetwork %1, %2", key, event["EventReason"]:"" );
    // store the value on exiting
    if( event["EventReason"]:"" == "ValueChanged")
    {
        string subnet = (string) UI::QueryWidget( `id( "subnet"), `Value);
        string netmask = (string) UI::QueryWidget( `id( "netmask"), `Value);

        if( IP::Check( subnet) && IP::Check( netmask))
            UI::ChangeWidget( `id( "broadcast"), `Value, IP::ComputeBroadcast( subnet, netmask));
    }
    if (event["ID"]:nil == `next) StoreNetwork (key, event);
    return nil;
  }

  /**
   * universal widget: initialize the string value of widget @param
   */
  define void InitCheckBox (string id) {
    UI::ChangeWidget (`id (id), `Value, networks[current_network,id]:false);
  }

  /**
   * initialize the value of combo box
   */
  define void InitCombo (string id) {
    list<term> items = maplist (string name, map n, networks, {
      return `item (`id (name), name, name == "admin");
    });
    UI::ChangeWidget (`id (id), `Items, items);
  }

  /**
   * handler network selection combo
   */
  define symbol HandleNetworkSelect (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StoreNetwork (key, event);
    string selected = (string) UI::QueryWidget (`id(key), `Value);
    if (selected != current_network)
    {
      foreach (string key, ["netmask", "subnet", "add_bridge"], {
        StoreNetwork (key, $[]);
      });
      current_network   = selected;
      foreach (string key, ["netmask", "subnet"], {
        InitNetwork (key);
      });
      InitCheckBox ("add_bridge");
    }
    return nil;
  }

map<string, map> widget_description	= $[
    "administrator" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Administrator"),
	// help text
	"help"		: _("<p>adminhelp</p>"),
    ],
    // ---------------- widgets for Network tab
    "network_select" : $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify ],
	// checkbox label
	"label"		: _("Networks"),
	// help text
	"help"		: _("FIXME"),
	"init"		: InitCombo,
	"handle"	: HandleNetworkSelect,
    ],
    "subnet" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Subnet"),
        "handle_events" : [ "ValueChanged" ],
	// help text
	"help"		: _("<p>subnet help</p>"),
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
    "netmask" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Netmask"),
        "handle_events" : [ "ValueChanged" ],
	// help text
	"help"		: _("<p>netmask help</p>"),
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
    "broadcast" : $[
	"widget"	: `textentry,
	"label"		: _("Broadcast"),
	"help"		: _("<p>broadcast</p>"),
	"opt"		: [ `disabled ]
    ],
    "add_bridge" : $[
	"widget"	: `checkbox,
	// checkbox label
	"label"		: _("Add Bridge"),
	// help text
	"help"		: _("<p>add bridge</p>"),
	"init"		: InitCheckBox,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
    ],
];

// description of tab layouts
map get_tabs_descr () {
    return $[
    "admin" : $[
	// tab header
	"header"	: _("Administration Settings"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
	    `VSpacing (0.4),
            "administrator",
	    `VStretch ()
	), `HSpacing(2)),
	"widget_names" : [
            "administrator",
	],
    ],
    "networks"	: $[
	// tab header
	"header"	: _("Networks"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
	    `VSpacing (0.4),
            "network_select",
	    `VSpacing (),
	    "subnet",
	    "netmask",
	    "broadcast",
	    `VSpacing (0.4),
	    `Left ("add_bridge"),
	    `VStretch ()
	), `HSpacing (2)),
	"widget_names" : [
            "network_select", "subnet", "netmask", "broadcast", "add_bridge",
	],
    ],
    ];
}

symbol OverviewDialog() {

    networks    = Crowbar::networks;

    widget_description["tab"] = CWMTab::CreateWidget($[
	"tab_order"	: [ "admin", "networks" ],
	"tabs"		: get_tabs_descr (),
	"widget_descr"	: widget_description,
	"initial_tab"	: "admin",
    ]);

    Wizard::SetContentsButtons("", `VBox (), HELPS["overview"]:"",
        Label::BackButton(), Label::FinishButton());

    symbol ret = CWM::ShowAndRun ($[
	"widget_names"		: [
	    "tab"
	],
	"widget_descr"		: widget_description,
	"contents"		: `VBox ("tab"),
	// default dialog caption
        "caption"               : _("Crowbar Configuration Overview"),
	"abort_button"		: nil,
    ]);
    y2milestone ("Returning %1", ret);
    if (ret == `next)
    {
      Crowbar::networks        = networks;
    }
// FIXME validate the numbers
// FIXME compute Broadcast address
    return ret;
}

/* EOF */
}
